# 빙고 - 2578

![Solved.ac
Tier](https://img.shields.io/badge/solved.ac-Silver%20IV-435F7A?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/2578)


`#구현` `#시뮬레이션` `#O(N^2)`

---

### 문제
빙고 게임은 다음과 같은 방식으로 이루어진다.

먼저 아래와 같이 25개의 칸으로 이루어진 빙고판에 1부터 25까지 자연수를 한 칸에 하나씩 쓴다

![](https://upload.acmicpc.net/5e2e03f0-5561-43c3-9b65-a752837732ef/-/preview/)


다음은 사회자가 부르는 수를 차례로 지워나간다. 예를 들어 5, 10, 7이 불렸다면 이 세 수를 지운 뒤 빙고판의 모습은 다음과 같다.

![](https://upload.acmicpc.net/6fc024b4-5bf7-42de-b303-406db2e3ff5b/-/preview/)


차례로 수를 지워가다가 같은 가로줄, 세로줄 또는 대각선 위에 있는 5개의 모든 수가 지워지는 경우 그 줄에 선을 긋는다.

![](https://upload.acmicpc.net/b5ffac7e-7db4-4d54-bf2b-63ac7d6807d8/-/preview/)


이러한 선이 세 개 이상 그어지는 순간 "빙고"라고 외치는데, 가장 먼저 외치는 사람이 게임의 승자가 된다.

![](https://upload.acmicpc.net/f86e3bcc-54da-420a-8f06-9600cb06eeaa/-/preview/)


철수는 친구들과 빙고 게임을 하고 있다. 철수가 빙고판에 쓴 수들과 사회자가 부르는 수의 순서가 주어질 때, 사회자가 몇 번째 수를 부른 후 철수가 "빙고"를 외치게 되는지를 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄부터 다섯째 줄까지 빙고판에 쓰여진 수가 가장 위 가로줄부터 차례대로 한 줄에 다섯 개씩 빈 칸을 사이에 두고 주어진다. 여섯째 줄부터 열째 줄까지 사회자가 부르는 수가 차례대로 한 줄에 다섯 개씩 빈 칸을 사이에 두고 주어진다. 빙고판에 쓰여진 수와 사회자가 부르는 수는 각각 1부터 25까지의 수가 한 번씩 사용된다.

### 출력
첫째 줄에 사회자가 몇 번째 수를 부른 후 철수가 "빙고"를 외치게 되는지 출력한다.

<hr>

### 핵심 풀이 전략

`메모리: 14360 KB`
`시간: 108 ms`

HashMap 과 int[][]을 활용한다.

이중 for문을 통해 int[][]에 철수의 빙고판을 저장. 이 때 Map을 통해 값을 저장할 때, i, j 주소도 저장.

마찬가지로 이중 for문으로 각 반복마다 Map을 통해 사회자가 부르는 값의 주소를 얻는다.
int[][]에서 해당 주소의 값을 0으로 바꾼다.

check() 메소드를 통해 각 반복마다 한줄에 "00000" 이란 String이 있는지 카운팅한다.
카운팅한 수가 3이상일 경우 반복을 중단한다.

---

### 삽질 기록 🧠

- **잘못된 String 형 변환**
    - 가로 코드를 검사 할 때, Arrays.toString(list) 메소드를 사용
    - 값이 '[0, 10, 23, 9, 19]' 형태로 변환되기에 비교가 불가능
    - StringBuilder() 활용하여 문제 해결

- **잘못된 인덱스 사용**
    - 가로 코드 검사할 때, [i] 대신 [0] 으로 고정된 값 사용
    - 위 실수 때문에 가로 줄은 매번 첫번째 줄만 검사

- **잘못된 Map 활용**
    - Map의 key로 빙고 번호를 두고, 주소를 값으로 두어야 하는데, 그 반대로 둠
    - 사회자가 부르는 번호를 받아도 해당 값의 주소를 알 수 없음
---

### 배운 점
- Arrays.toString(list) 의 방식이 "[list]" 로 바꾼다는걸 알게 되었다.

### 보완할 점
- 형 변환에 대해 조금 더 공부가 필요하다.
- 내가 작성한 빙고 검사 로직은 문제의 조건이 바뀔 시 유연하게 대처가 어렵다.
- 빙고 발생 조건은 row[i] 또는 col[i]에서 0의 갯수가 n개일 때이다. 이를 활용해 주소(i, j)로 굳이 값을 찾지 않아도 `rol[i]++, col[j]++`를 통해 빙고를 검사할 수 있다.
- 위 검사 방식 `'0의 갯수가 n개인가?'` 를 확인하는 방식이 조금 더 직관적이고, 유연한 방법이다.
- 빙고는 사회자가 **12번째 번호**를 부를 때 부터 생길 수 있다. 따라서 빙고를 검사하는 로직을 **12번째 반복 이후**로 두면 최적화 할 수 있다.
