# 비밀번호 발음하기 - 4659

![Solved.ac
Tier](https://img.shields.io/badge/solved.ac-Silver%20IV-435F7A?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/4659)


`#구현` `#문자열` `#O(N)`

---

### 문제
좋은 패스워드를 만드는것은 어려운 일이다. 대부분의 사용자들은 buddy처럼 발음하기 좋고 기억하기 쉬운 패스워드를 원하나, 이런 패스워드들은 보안의 문제가 발생한다. 어떤 사이트들은 xvtpzyo 같은 비밀번호를 무작위로 부여해 주기도 하지만, 사용자들은 이를 외우는데 어려움을 느끼고 심지어는 포스트잇에 적어 컴퓨터에 붙여놓는다. 가장 이상적인 해결법은 '발음이 가능한' 패스워드를 만드는 것으로 적당히 외우기 쉬우면서도 안전하게 계정을 지킬 수 있다.

회사 FnordCom은 그런 패스워드 생성기를 만들려고 계획중이다. 당신은 그 회사 품질 관리 부서의 직원으로 생성기를 테스트해보고 생성되는 패스워드의 품질을 평가하여야 한다. 높은 품질을 가진 비밀번호의 조건은 다음과 같다.

모음(a,e,i,o,u) 하나를 반드시 포함하여야 한다.
모음이 3개 혹은 자음이 3개 연속으로 오면 안 된다.
같은 글자가 연속적으로 두번 오면 안되나, ee 와 oo는 허용한다.
이 규칙은 완벽하지 않다;우리에게 친숙하거나 발음이 쉬운 단어 중에서도 품질이 낮게 평가되는 경우가 많이 있다.

### 입력
입력은 여러개의 테스트 케이스로 이루어져 있다.

각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 테스트할 패스워드가 주어진다.

마지막 테스트 케이스는 end이며, 패스워드는 한글자 이상 20글자 이하의 문자열이다. 또한 패스워드는 대문자를 포함하지 않는다.

### 출력
각 테스트 케이스를 '예제 출력'의 형태에 기반하여 품질을 평가하여라.

<hr>

### 핵심 풀이 전략

`메모리: 15868 KB`
`시간: 116 ms`

이 문제는 주어진 3가지 규칙을 문자열의 처음부터 끝까지 순회하며 하나의 for 루프 안에서 동시에 검사하는 것이 가장 효율적이다.

규칙 1: 모음(a,e,i,o,u) 하나를 반드시 포함한다.

boolean 타입의 hasVowel 플래그를 두어, 순회 중 모음을 만나면 true로 변경한다. 루프가 끝난 후에도 false이면 규칙 위반이다.

규칙 2: 모음이 3개 혹은 자음이 3개 연속으로 오면 안 된다.

연속된 모음과 자음의 개수를 세는 vowelCount, consonantCount 변수를 둔다.

모음을 만나면 vowelCount를 1 증가시키고, consonantCount는 0으로 초기화한다.

자음을 만나면 반대로 consonantCount를 1 증가시키고, vowelCount를 0으로 초기화한다.

매 글자를 확인할 때마다 두 변수 중 하나라도 3 이상이 되면 즉시 규칙 위반으로 판정한다.

규칙 3: 같은 글자가 연속적으로 두 번 오면 안 되나, 'ee', 'oo'는 허용한다.

현재 문자와 바로 이전 문자(st.charAt(i)와 st.charAt(i-1))를 비교한다.

두 문자가 같을 경우, 그 문자가 'e'나 'o'가 아니라면 규칙 위반이다.

핵심: 세 규칙 중 **어느 하나라도 위반하는 즉시 "not acceptable"**로 결론짓고 다음 테스트 케이스로 넘어가는 것이 효율적이다.


---

### 삽질 기록 🧠

- **잘못된 루프 범위 설정으로 인한 로직 오류**
    - 같은 글자가 연속되는지 확인하는 for 루프의 조건을 i < st.length()-2로 설정했다. 이로 인해 문자열의 마지막 두 글자에 대한 비교(st.charAt(st.length()-2)와 st.charAt(st.length()-1))가 누락되었다. 예를 들어 "pass"와 같은 입력에서 마지막 "ss"를 잡아내지 못하는 치명적인 오류가 발생했다.

---

### 배운 점
- for문 경계를 잘 생각하자

### 보완할 점
- 모음이 하나라도 포함되었는지 확인하기 위해 모든 문자를 Set에 넣은 후, 마지막에 'a', 'e', 'i', 'o', 'u'가 각각 없는지를 && 연산으로 모두 확인했다.
- 간단한 boolean 플래그로 해결할 수 있는 문제를, 더 복잡하고 메모리를 사용하는 자료구조로 해결하려 했다. 이는 문제의 본질에 맞는 가장 단순한 해결책을 떠올리는 훈련이 부족했기 때문이다.