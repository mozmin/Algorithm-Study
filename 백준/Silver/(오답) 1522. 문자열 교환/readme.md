# 문자열교환 - 1522

![Solved.ac
Tier](https://img.shields.io/badge/solved.ac-Silver%20IV-435F7A?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/1522)


`#브루트포스` `#슬라이딩 윈도우` `#O(N)` `#정답코드참고`

---

### 문제
a와 b로만 이루어진 문자열이 주어질 때,  a를 모두 연속으로 만들기 위해서 필요한 교환의 회수를 최소로 하는 프로그램을 작성하시오.

이 문자열은 원형이기 때문에, 처음과 끝은 서로 인접해 있는 것이다.

예를 들어,  aabbaaabaaba이 주어졌을 때, 2번의 교환이면 a를 모두 연속으로 만들 수 있다.

### 입력
첫째 줄에 문자열이 주어진다. 문자열의 길이는 최대 1,000이다.

### 출력
첫째 줄에 필요한 교환의 회수의 최솟값을 출력한다.

<hr>

### 핵심 풀이 전략

`메모리: 14388 KB`
`시간: 104 ms`

해당 문제의 시작은 '문자열의 최종 형태는 어떤 모습일까?' 에서 시작된다. 
문자열 'abab'라고 한다면 결과는 'aabb'가 되어야 한다.
2개의 a가 모여있으면 되므로, 2개의 슬라이딩 윈도우 안에 b 갯수 중 최솟값이 문제의 정답이 된다.

---

### 삽질 기록 🧠

- **bfs 방식으로 해결하려 함**
    - 문제에서 **'최소 변경 횟수'** 라는 키워드만 보고 BFS를 생각했지만, 모든 경우의 수를 다 따지기에는 공간이 부족함.
    - a 하나와 b 하나를 교환하는 모든 경우의 수를 고려하면 시간 초과가 발생할 것임.
    - '어떻게 교환할까?' 에만 초점을 맞춤

---

### 배운 점 & 보완할 점
- '최소 횟수' 문제라고 무조건 BFS를 떠올리지 말자.
- 문제의 '과정'을 시뮬레이션하기 전에, **'최종 목표 상태'**의 특징을 먼저 분석하자.
