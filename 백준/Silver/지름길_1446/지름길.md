# 지름길 - 1446

![Solved.ac
Tier](https://img.shields.io/badge/solved.ac-Silver%20I-435F7A?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/1446)


`#다익스트라` `#그래프 이론` `#O(N)`

---

### 문제
매일 아침, 세준이는 학교에 가기 위해서 차를 타고 D킬로미터 길이의 고속도로를 지난다. 이 고속도로는 심각하게 커브가 많아서 정말 운전하기도 힘들다. 어느 날, 세준이는 이 고속도로에 지름길이 존재한다는 것을 알게 되었다. 모든 지름길은 일방통행이고, 고속도로를 역주행할 수는 없다.

세준이가 운전해야 하는 거리의 최솟값을 출력하시오.

### 입력
첫째 줄에 지름길의 개수 N과 고속도로의 길이 D가 주어진다. N은 12 이하인 양의 정수이고, D는 10,000보다 작거나 같은 자연수이다. 다음 N개의 줄에 지름길의 시작 위치, 도착 위치, 지름길의 길이가 주어진다. 모든 위치와 길이는 10,000보다 작거나 같은 음이 아닌 정수이다. 지름길의 시작 위치는 도착 위치보다 작다.

### 출력
세준이가 운전해야하는 거리의 최솟값을 출력하시오.

<hr>

### 핵심 풀이 전략

`메모리: 17920 KB`
`시간: 184 ms`

이 문제는 연속된 증가/감소 수열의 최대 길이를 찾는 문제. 두 개의 카운터로 O(N) 시간 복잡도에 해결.

1. 두 개의 카운터(변수) 선언:
- increase_count: 연속해서 커지거나(같아지는 것 포함) 있는 수열의 길이 저장.
- decrease_count: 연속해서 작아지거나(같아지는 것 포함) 있는 수열의 길이 저장.
- max_len: 지금까지 찾은 가장 긴 수열의 길이 저장.

2. 반복문 순회:
- 수열의 첫 번째 숫자부터 끝까지 순회.
- 각 숫자를 이전 숫자와 비교하며 카운터 업데이트.
- 현재 숫자가 이전 숫자보다 크거나 같으면, increase_count 1 증가. decrease_count는 1로 초기화.
- 현재 숫자가 이전 숫자보다 작거나 같으면, decrease_count 1 증가. increase_count는 1로 초기화.
- 매 반복마다 max_len과 increase_count, decrease_count 중 가장 큰 값을 비교하여 max_len 업데이트.

3. 예외 처리:
- N이 1일 경우, 정답은 1. 이 경우를 따로 처리하거나, 초기 카운터 값을 1로 설정하여 일반적인 로직으로 해결.

---

### 삽질 기록 🧠

- 배열 전체를 순회하며 max 값을 업데이트하는 것을 놓침: 중간에 증가/감소 수열이 꺾일 때만 max_len을 업데이트. 이는 잘못된 방식. 매 반복마다 max_len을 갱신하는 것이 중요.

- 단일 입력(N=1) 케이스 간과: 수열의 길이가 1일 경우를 고려하지 않아 오류 발생. 이 경우 max_len의 초기값을 1로 설정하면 해결 가능.

- 모두 같은 숫자인 경우: 5, 5, 5, 5, 5와 같이 모든 숫자가 같은 경우, 증가하는 수열이자 감소하는 수열. 두 카운터 모두 증가하므로, 두 카운터를 각각 관리하는 방식은 이 경우도 올바르게 처리.

---

### 배운 점 | 보안할 점
- 이 문제는 투 포인터나 다이내믹 프로그래밍 개념을 활용할 수 있지만, 가장 효율적이고 직관적인 방법은 증가/감소 카운터 두 개를 사용.

- DP 배열을 활용한 풀이 가능: dp_inc[i]는 i번째 원소를 끝으로 하는 가장 긴 증가 수열의 길이를, dp_dec[i]는 가장 긴 감소 수열의 길이를 저장하여 풀이 가능.

- 문제 풀이 시 다양한 예외 케이스를 머릿속으로 시뮬레이션해 보는 습관을 가짐. 특히 길이가 짧은 경우(1), 모든 요소가 같은 경우 등은 기본적인 테스트 케이스로 항상 검토.