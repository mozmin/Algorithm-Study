# 쉬운최단거리 - 14940

![Solved.ac
Tier](https://img.shields.io/badge/solved.ac-Silver%20IV-435F7A?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/14940)


`#그래프 탐색` `#BFS` `#O(N * M)`

---

### 문제
지도가 주어지면 모든 지점에 대해서 목표지점까지의 거리를 구하여라.

문제를 쉽게 만들기 위해 오직 가로와 세로로만 움직일 수 있다고 하자.

### 입력
지도의 크기 n과 m이 주어진다. n은 세로의 크기, m은 가로의 크기다.(2 ≤ n ≤ 1000, 2 ≤ m ≤ 1000)

다음 n개의 줄에 m개의 숫자가 주어진다. 0은 갈 수 없는 땅이고 1은 갈 수 있는 땅, 2는 목표지점이다. 입력에서 2는 단 한개이다.

### 출력
각 지점에서 목표지점까지의 거리를 출력한다. 원래 갈 수 없는 땅인 위치는 0을 출력하고, 원래 갈 수 있는 땅인 부분 중에서 도달할 수 없는 위치는 -1을 출력한다.

<hr>

### 핵심 풀이 전략

`메모리: 56696 KB`
`시간: 696 ms`

해당 문제는 특정 지점(2)으로부터 모든 도달 가능한 지점(1)까지의 최단 거리를 구하는 단일 시작점 최단 경로(SSSP) 문제임.

풀이 전략은 다음과 같음:

단 한 번의 BFS 실행을 전략으로 채택. 모든 지점에서 BFS를 반복하면 $O(N^2M^2)$의 시간 복잡도로 메모리 초과(MLE) 및 시간 초과(TLE)가 발생함.

목표 지점(2)을 시작점으로 설정하고 BFS를 역방향으로 탐색하여 모든 **갈 수 있는 땅(1)**의 거리를 한 번에 계산함.

결과 배열(result)을 사전 초기화하여 도달 여부를 판단.

**갈 수 없는 벽(0)**은 0을 출력.

**갈 수 있는 땅(1)**은 -1을 출력하여 BFS를 통해 도달하지 못하면 최종적으로 -1을 출력하도록 처리.

**시작 지점(2)**은 0을 출력.

---

### 삽질 기록 🧠

- **비효율적인 BFS 실행으로 인한 MLE/TLE 발생**
    - 초기 코드에서 모든 board[i][j] != 0인 지점(땅과 목표 지점)마다 bfs()를 실행하여 시간 및 메모리 복잡도가 폭발적으로 증가함. 
  
- **결과 배열 초기화 로직 오류**
    - result 배열을 일괄적으로 -1로만 초기화하여, **원래 갈 수 없는 벽(0)**의 결과 값까지 -1로 출력되는 오류가 발생함. 벽(0)은 반드시 0으로 초기화해야 함.

- **시작점 거리 설정 위치 오류**
    - BFS를 시작하기 전에 시작점(2)의 거리를 result[startY][startX] = 0으로 설정해야 하나, 이를 누락하거나 BFS 함수 종료 시점에 설정하여 초기화 로직과 충돌함.

---

### 배운 점 | 보안할 점
- 그리드 형태의 최단 거리 문제 중 단일 시작점에서 모든 지점까지의 거리를 요구하는 경우, BFS를 단 한 번만 실행하는 것이 핵심 전략임을 확인함.

- 출력 조건이 까다로운 문제(도달 불가능: -1, 벽: 0, 최단 거리: >0)에서는, 입력 단계에서 result 배열의 모든 값을 조건에 맞게 정확히 초기화한 후, BFS는 계산된 거리만 덮어쓰도록 설계하는 것이 풀이의 안정성을 높이는 방법임.

- 1-based 인덱스(N+1, M+1) 사용 시 경계 조건(dy > 0 && dy <= N)을 실수 없이 확인해야 함.
