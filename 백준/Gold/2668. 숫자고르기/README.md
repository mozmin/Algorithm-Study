# [Gold V] 숫자고르기 - 2668 

![Solved.ac Tier](https://img.shields.io/badge/solved.ac-Gold%20V-F29D16?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/2668)


`#그래프 이론` `#깊이 우선 탐색` `#O()` `정답 코드 참고`

### 성능 요약

메모리: 15812 KB, 시간: 116 ms

### 분류

그래프 이론, 그래프 탐색, 깊이 우선 탐색

### 제출 일자

2025년 9월 30일 01:43:02

### 문제 설명

<p>세로 두 줄, 가로로 N개의 칸으로 이루어진 표가 있다. 첫째 줄의 각 칸에는 정수 1, 2, …, N이 차례대로 들어 있고 둘째 줄의 각 칸에는 1이상 N이하인 정수가 들어 있다. 첫째 줄에서 숫자를 적절히 뽑으면, 그 뽑힌 정수들이 이루는 집합과, 뽑힌 정수들의 바로 밑의 둘째 줄에 들어있는 정수들이 이루는 집합이 일치한다. 이러한 조건을 만족시키도록 정수들을 뽑되, 최대로 많이 뽑는 방법을 찾는 프로그램을 작성하시오. 예를 들어, N=7인 경우 아래와 같이 표가 주어졌다고 하자.</p>

<p><img alt="" src="" style="width: 262px; height: 61px; "></p>

<p>이 경우에는 첫째 줄에서 1, 3, 5를 뽑는 것이 답이다. 첫째 줄의 1, 3, 5밑에는 각각 3, 1, 5가 있으며 두 집합은 일치한다. 이때 집합의 크기는 3이다. 만약 첫째 줄에서 1과 3을 뽑으면, 이들 바로 밑에는 정수 3과 1이 있으므로 두 집합이 일치한다. 그러나, 이 경우에 뽑힌 정수의 개수는 최대가 아니므로 답이 될 수 없다.</p>

### 입력 

 <p>첫째 줄에는 N(1≤N≤100)을 나타내는 정수 하나가 주어진다. 그 다음 줄부터는 표의 둘째 줄에 들어가는 정수들이 순서대로 한 줄에 하나씩 입력된다.</p>

### 출력 

 <p>첫째 줄에 뽑힌 정수들의 개수를 출력하고, 그 다음 줄부터는 뽑힌 정수들을 작은 수부터 큰 수의 순서로 한 줄에 하나씩 출력한다.</p>

<hr>

### 핵심 풀이 전략

`메모리: 15812 KB`
`시간: 116 ms`

이 문제의 핵심은 주어진 숫자 관계를 그래프로 생각하고, 그 안의 사이클(Cycle)을 찾는 것

그래프 모델링: 1부터 N까지의 숫자를 각각의 노드(정점)라고 생각. 그리고 첫 번째 줄의 숫자 i에서 두 번째 줄의 숫자 list[i]로 가는 단방향 간선(Edge)이 있다고 모델링 가능. 
예를 들어 list[1] = 3 이라면 1 -> 3 간선이 존재하는 것.

'정답'의 의미: 문제에서 요구하는 "뽑은 숫자 집합과 그에 해당하는 값의 집합이 같은 경우"는, 이 그래프에서 사이클을 형성하는 노드들의 집합과 정확히 일치. 
사이클에 속한 노드들은 화살표를 따라가다 보면 결국 자기 자신 또는 사이클 내의 다른 노드로 돌아오게 되므로, 외부로 빠져나가지 않고 자신들만의 닫힌 집합을 이룸.

해결 알고리즘: 따라서 이 문제는 **DFS(깊이 우선 탐색)**를 사용하여 그래프의 모든 노드를 한 번씩 방문하며 사이클을 찾아내는 방식으로 해결. 
visited[] 배열로 방문 여부를, finished[] 배열로 해당 노드의 탐색이 완전히 끝났는지 여부를 체크하며 사이클을 판별하는 것이 정석적인 풀이법.

---

### 삽질 기록 🧠

- **잘못된 접근: 조합(Combination)을 이용한 완전 탐색**
    - 가장 큰 실수는 문제의 본질을 '그래프 사이클 찾기'가 아닌 '조건을 만족하는 모든 조합 찾기' 로 접근한 것
    - 1개 뽑는 조합, 2개 뽑는 조합, ..., N개 뽑는 조합을 모두 만들어서 조건을 확인하는 방식은 N의 크기가 조금만 커져도 경우의 수가 기하급수적으로 늘어남. 문제의 N 제한은 100이었는데, 이 경우 조합 방식은 100% 시간 초과 또는 메모리 초과를 유발
    - 문제의 제약 조건(N의 크기)을 보고 풀이법의 시간 복잡도를 먼저 예측하는 습관이 부족
- **치명적인 구현 버그: 재귀 호출 중 원본 데이터 훼손**
  - 어렵게 디버깅했던 부분으로, DFS와 백트래킹 로직에 대한 이해 부족이 원인
  - DFS 함수 내에서 Collections.sort(valueList)를 호출하여 원본 리스트를 직접 정렬
  - 이로 인해 재귀 호출이 끝나고 이전 상태로 돌아가는 백트래킹 과정에서 리스트의 순서가 꼬여버림
  - list.remove(list.size()-1)가 의도와 다른 엉뚱한 요소를 제거하면서 전체 로직에 오류가 발생
  - 재귀적으로 상태를 변경하고 복원할 때, 원본 데이터의 **불변성**을 지키지 못함.

---

### 배운 점 & 보완할 점
- 숫자 간의 관계나 특정 규칙이 주어지는 문제는 그래프로 모델링할 수 있는지 항상 먼저 생각해보는 습관을 길러야 됨. 
- 문제의 제약 조건을 통해 시간 복잡도를 가늠하고, 그에 맞는 알고리즘(완전 탐색, DP, 그래프 탐색 등)을 선택하는 훈련이 필요.
- DFS/백트래킹 구현 시, 파라미터로 넘긴 객체(리스트, 배열 등)가 수정될 경우 어떤 부작용이 생길지 항상 생각 해야함. 
- 상태를 확인만 해야 할 때는 반드시 복사본을 활용하여 원본 데이터가 훼손되지 않도록 방어적인 코드를 작성하는 연습 필요.
