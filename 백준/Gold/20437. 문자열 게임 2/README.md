# [Gold V] 문자열 게임 2 - 20437 

![Solved.ac Tier](https://img.shields.io/badge/solved.ac-Gold%20V-F29D16?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/20437)


`#슬라이딩 윈도우` `#문자열` `#O(T+N)` `정답 코드 참고`

### 성능 요약

메모리: 36884 KB, 시간: 464 ms

### 분류

문자열, 슬라이딩 윈도우

### 제출 일자

2025년 9월 26일 20:10:29

### 문제 설명

<p>작년에 이어 새로운 문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.</p>

<ol>
	<li>알파벳 소문자로 이루어진 문자열 W가 주어진다.</li>
	<li>양의 정수 K가 주어진다.</li>
	<li>어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.</li>
	<li>어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.</li>
</ol>

<p>위와 같은 방식으로 게임을 T회 진행한다.</p>

### 입력 

 <p>문자열 게임의 수 T가 주어진다. (1 ≤ T ≤ 100)</p>

<p>다음 줄부터 2개의 줄 동안 문자열 W와 정수 K가 주어진다. (1 ≤ K ≤ |W| ≤ 10,000) </p>

### 출력 

 <p>T개의 줄 동안 문자열 게임의 3번과 4번에서 구한 연속 문자열의 길이를 공백을 사이에 두고 출력한다.</p>

<p>만약 만족하는 연속 문자열이 없을 시 -1을 출력한다.</p>

<hr>

### 핵심 풀이 전략

`메모리: 36884 KB`
`시간: 464 ms`

이 문제는 '전처리 후 탐색' 방식과 슬라이딩 윈도우를 활용하는 것이 핵심이다.

(전처리) 문자열 W를 단 한 번만 순회하면서, 각 알파벳이 어느 위치(인덱스)에 등장하는지 Map이나 배열에 전부 기록.

(탐색) 원본 문자열은 이제 버리고, 위에서 만든 위치 기록표(map)만 참고. 
각 알파벳(문자)가 몇번쨰 인덱스에 있는지 보고, 슬라이딩 윈도우를 적용해 K개 묶음의 길이를 계산하고 최소/최대값을 갱신.

이렇게 하면 불필요한 반복 계산을 모두 없애고 알파벳 26개의 고정된 상수 값을 사용하여 O(N^2)이 아닌 O(N)의 시간 복잡도로 문제를 해결할 수 있음.

---

### 삽질 기록 🧠

- **각 알파벳의 갯수를 저장함**
    - 정답 코드 처럼, 각 알파벳의 위치(인덱스)를 저장해야 하지만, 단순 갯수만 저장하여 활용을 못함.
- **잘못된 변수 사용 (인덱스 오류)**
  - 알파벳(문자)의 갯수를 셀 때, charAt() 인덱스로 바깥 for 문의 i를 사용. -> j로 올바르게 수정.
- **불필요한 중복 계산 (O(N²) 접근)**
  - 알파벳(문자)를 모두 Map<>에 저장한뒤, Map<>으로 방문을 하는 것이 아닌 다시 문자 W의 문자열을 하나하나 방문함.
  - Map<>으로 방문하면 알파벳이 26개로 시간복잡도 O(1)를 가질 수 있음.
- **슬라이딩 윈도우 반복 조건 오류**
  - 0 < value.size()-K 로 잘못된 범위를 반복 처리함.
  - 0 <= value.size()-K로 수정.

---

### 배운 점 & 보완할 점
- 처음에 알파벳 갯수를 먼저 Map<>에 저장하는 아이디어 까지는 좋았지만, 막상 갯수를 알아서 할 수 있는게 없었다. 어떤 값을 저장해야 활용할 수 있는지 생각해야한다.
- 슬라이딩 윈도우에서 가장 중요한건, 반복문 범위 설정이다. 특히나 인덱스는 0부터 시작하므로 이에 유념하자.
- 해당 문제는 시간이 1초였다. 1초는 대략 10^8 이다. 문제에 N이나 K 값의 범위를 보고 시간복잡도를 잘 계산하자.
