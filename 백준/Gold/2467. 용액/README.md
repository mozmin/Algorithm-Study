# [Gold V] 용액 - 2467 

![Solved.ac Tier](https://img.shields.io/badge/solved.ac-Gold%20V-F29D16?style=for-the-badge&logo=solved.ac)

[문제 링크](https://www.acmicpc.net/problem/2467)


`#이분 탐색` `#두 포인터` `#O(N)`

### 성능 요약

메모리: 28412 KB, 시간: 332 ms

### 분류

이분 탐색, 두 포인터

### 제출 일자

2025년 10월 6일 13:05:58

### 문제 설명

<p>KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.</p>

<p>같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. </p>

<p>예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.</p>

<p>산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.</p>

### 출력 

 <p>첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.</p>

<hr>

### 핵심 풀이 전략

`메모리: 28412 KB`
`시간: 332 ms`

- 투 포인터 이동: left 포인터는 배열의 시작(가장 작은 값)에, right 포인터는 배열의 끝(가장 큰 값)에 위치시킴.

- 범위 좁히기:
  - 합 > 0 이면, 합을 줄이기 위해 right 포인터를 감소시킴.
  - 합 < 0 이면, 합을 키우기 위해 left 포인터를 증가시킴.
  - 최솟값 갱신: 현재 합의 절댓값이 기존의 minDiff보다 작으면 최솟값을 갱신하고 결과 용액을 저장함.

- 0 발견 시 종료: 합이 0일 경우, 가장 이상적인 값이므로 즉시 반복문을 종료함.

---

### 삽질 기록 🧠

- **비효율적인 탐색**
  - 투 포인터 방식을 사용하지 않고, 이전 인덱스 값들을 사용하는 이중 for문 방식을 사용
  - 시간 초과 발생 -> 비효율적인 탐색

- **최솟값 갱신 로직 오류**
    - minDiff를 갱신할 때 minDiff = diff;처럼 부호가 있는 값을 저장함. 최솟값은 절댓값을 기준으로 판단해야 하므로, minDiff = Math.abs(diff);로 저장했어야 함.

- **sum = 0 조건 처리 미**
  - 합이 정확히 0일 경우 최솟값 갱신만 하고 탐색을 계속하여 불필요한 연산을 수행함. diff == 0일 경우 **break**를 통해 탐색을 즉시 종료하여 효율성을 높여야 함.

---

### 배운 점 & 보완할 점
- 투 포인터, 이분 탐색 등의 알고리즘을 사용하기 전, 입력 배열의 정렬 상태를 항상 최우선으로 확인하여 누락하지 않도록 조치함.
- 최적의 해답(합이 0)을 찾았을 경우, 불필요한 반복을 피하기 위해 break 문으로 탐색을 종료하여 시간 효율을 확보 필요.
